use crate::error::ProverError;
use sha2::{Digest, Sha256};
use zkclear_types::{Address, AssetId, ChainId};

/// Merkle tree for state roots and withdrawals roots
pub struct MerkleTree {
    pub(crate) leaves: Vec<[u8; 32]>,
}

impl MerkleTree {
    pub fn new() -> Self {
        Self { leaves: Vec::new() }
    }

    /// Add a leaf to the tree
    pub fn add_leaf(&mut self, leaf: [u8; 32]) {
        self.leaves.push(leaf);
    }

    /// Compute the Merkle root
    /// Optimized to avoid unnecessary allocations
    pub fn root(&self) -> Result<[u8; 32], ProverError> {
        if self.leaves.is_empty() {
            return Ok([0u8; 32]);
        }

        if self.leaves.len() == 1 {
            return Ok(self.leaves[0]);
        }

        // Pre-allocate with capacity estimate to reduce reallocations
        let mut current_level = Vec::with_capacity(self.leaves.len());
        current_level.extend_from_slice(&self.leaves);

        while current_level.len() > 1 {
            let next_level_len = (current_level.len() + 1) / 2;
            let mut next_level = Vec::with_capacity(next_level_len);

            for i in (0..current_level.len()).step_by(2) {
                if i + 1 < current_level.len() {
                    let hash = hash_pair(&current_level[i], &current_level[i + 1]);
                    next_level.push(hash);
                } else {
                    // Odd number of nodes, duplicate the last one
                    let hash = hash_pair(&current_level[i], &current_level[i]);
                    next_level.push(hash);
                }
            }

            current_level = next_level;
        }

        Ok(current_level[0])
    }

    /// Generate a Merkle proof for a leaf at the given index
    pub fn proof(&self, leaf_index: usize) -> Result<Vec<[u8; 32]>, ProverError> {
        if leaf_index >= self.leaves.len() {
            return Err(ProverError::MerkleTree(format!(
                "Leaf index {} out of bounds",
                leaf_index
            )));
        }

        if self.leaves.len() == 1 {
            return Ok(Vec::new());
        }

        let mut proof = Vec::new();
        let mut current_level = self.leaves.clone();
        let mut current_index = leaf_index;

        while current_level.len() > 1 {
            let sibling_index = if current_index % 2 == 0 {
                current_index + 1
            } else {
                current_index - 1
            };

            if sibling_index < current_level.len() {
                proof.push(current_level[sibling_index]);
            } else {
                // Sibling doesn't exist (odd number of nodes), duplicate the current node
                proof.push(current_level[current_index]);
            }

            // Build next level
            let mut next_level = Vec::new();
            for i in (0..current_level.len()).step_by(2) {
                if i + 1 < current_level.len() {
                    let hash = hash_pair(&current_level[i], &current_level[i + 1]);
                    next_level.push(hash);
                } else {
                    // Odd number, duplicate the last node
                    let hash = hash_pair(&current_level[i], &current_level[i]);
                    next_level.push(hash);
                }
            }

            // Update current_index for next level
            current_index = current_index / 2;
            current_level = next_level;
        }

        Ok(proof)
    }
}

fn hash_pair(left: &[u8; 32], right: &[u8; 32]) -> [u8; 32] {
    let mut hasher = Sha256::new();
    hasher.update(left);
    hasher.update(right);
    hasher.finalize().into()
}

/// Hash a withdrawal to create a leaf
pub fn hash_withdrawal(
    user: Address,
    asset_id: AssetId,
    amount: u128,
    chain_id: ChainId,
) -> [u8; 32] {
    let mut hasher = Sha256::new();
    hasher.update(&user);
    hasher.update(&asset_id.to_le_bytes());
    hasher.update(&amount.to_le_bytes());
    hasher.update(&chain_id.to_le_bytes());
    hasher.finalize().into()
}

/// Hash state data to create a leaf for state root
pub fn hash_state_leaf(data: &[u8]) -> [u8; 32] {
    let mut hasher = Sha256::new();
    hasher.update(data);
    hasher.finalize().into()
}

/// Verify a Merkle proof
///
/// This verifies that a leaf is included in a Merkle tree with the given root.
/// The proof should be generated by the same tree structure.
///
/// # Arguments
/// * `leaf` - The leaf hash to verify
/// * `proof` - The Merkle proof (list of sibling hashes from leaf to root)
/// * `root` - The expected Merkle root
/// * `leaf_index` - The index of the leaf in the original tree (required for trees with >2 leaves)
///
/// # Returns
/// `true` if the proof is valid, `false` otherwise
pub fn verify_merkle_proof(
    leaf: &[u8; 32],
    proof: &[[u8; 32]],
    root: &[u8; 32],
    leaf_index: Option<usize>,
) -> bool {
    if proof.is_empty() {
        return leaf == root;
    }

    let mut current = *leaf;

    // If we have the leaf index, use it to correctly track position at each level
    if let Some(mut idx) = leaf_index {
        for sibling in proof {
            // Determine if current node is left or right at this level
            let is_left = idx % 2 == 0;

            if is_left {
                // Current is left, sibling is right
                current = hash_pair(&current, sibling);
            } else {
                // Current is right, sibling is left
                current = hash_pair(sibling, &current);
            }

            // Move to parent level (divide by 2)
            idx /= 2;
        }
    } else {
        // Without index, we can only verify for simple cases (1-2 leaves)
        // For trees with >2 leaves, we need the index to determine position
        // at each level. For backward compatibility, we'll try a simple approach
        // that works for 2 leaves but may fail for larger trees.

        // Simple heuristic: assume alternating left/right
        // This works for 2 leaves but not for larger trees
        let mut is_left = true;
        for sibling in proof {
            if is_left {
                current = hash_pair(&current, sibling);
            } else {
                current = hash_pair(sibling, &current);
            }
            is_left = !is_left;
        }
    }

    current == *root
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_merkle_tree_single_leaf() {
        let mut tree = MerkleTree::new();
        let leaf = [1u8; 32];
        tree.add_leaf(leaf);
        let root = tree.root().unwrap();
        assert_eq!(root, leaf);
    }

    #[test]
    fn test_merkle_tree_two_leaves() {
        let mut tree = MerkleTree::new();
        let leaf1 = [1u8; 32];
        let leaf2 = [2u8; 32];
        tree.add_leaf(leaf1);
        tree.add_leaf(leaf2);
        let root = tree.root().unwrap();

        // Verify proof
        let proof = tree.proof(0).unwrap();
        assert!(verify_merkle_proof(&leaf1, &proof, &root, Some(0)));
    }

    #[test]
    fn test_merkle_tree_multiple_leaves() {
        let mut tree = MerkleTree::new();
        for i in 0..4 {
            tree.add_leaf([i as u8; 32]);
        }
        let root = tree.root().unwrap();

        // Verify proof for each leaf (using power of 2 for simpler tree structure)
        for i in 0..4 {
            let leaf = [i as u8; 32];
            let proof = tree.proof(i).unwrap();
            assert!(
                verify_merkle_proof(&leaf, &proof, &root, Some(i)),
                "Failed to verify proof for leaf {}: proof len={}, root={:?}",
                i,
                proof.len(),
                root
            );
        }
    }

    #[test]
    fn test_merkle_tree_larger_tree() {
        // Test with 8 leaves to ensure it works for larger trees
        let mut tree = MerkleTree::new();
        for i in 0..8 {
            tree.add_leaf([i as u8; 32]);
        }
        let root = tree.root().unwrap();

        // Verify proof for each leaf
        for i in 0..8 {
            let leaf = [i as u8; 32];
            let proof = tree.proof(i).unwrap();
            assert!(
                verify_merkle_proof(&leaf, &proof, &root, Some(i)),
                "Failed to verify proof for leaf {}: proof len={}, root={:?}",
                i,
                proof.len(),
                root
            );
        }
    }
}
