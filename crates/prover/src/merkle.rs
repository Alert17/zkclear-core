use sha2::{Digest, Sha256};
use zkclear_types::{Address, AssetId, ChainId};
use crate::error::ProverError;

/// Merkle tree for state roots and withdrawals roots
pub struct MerkleTree {
    pub(crate) leaves: Vec<[u8; 32]>,
}

impl MerkleTree {
    pub fn new() -> Self {
        Self {
            leaves: Vec::new(),
        }
    }

    /// Add a leaf to the tree
    pub fn add_leaf(&mut self, leaf: [u8; 32]) {
        self.leaves.push(leaf);
    }

    /// Compute the Merkle root
    pub fn root(&self) -> Result<[u8; 32], ProverError> {
        if self.leaves.is_empty() {
            return Ok([0u8; 32]);
        }

        let mut current_level = self.leaves.clone();

        while current_level.len() > 1 {
            let mut next_level = Vec::new();
            
            for i in (0..current_level.len()).step_by(2) {
                if i + 1 < current_level.len() {
                    let hash = hash_pair(&current_level[i], &current_level[i + 1]);
                    next_level.push(hash);
                } else {
                    // Odd number of nodes, duplicate the last one
                    let hash = hash_pair(&current_level[i], &current_level[i]);
                    next_level.push(hash);
                }
            }
            
            current_level = next_level;
        }

        Ok(current_level[0])
    }

    /// Generate a Merkle proof for a leaf at the given index
    pub fn proof(&self, leaf_index: usize) -> Result<Vec<[u8; 32]>, ProverError> {
        if leaf_index >= self.leaves.len() {
            return Err(ProverError::MerkleTree(format!("Leaf index {} out of bounds", leaf_index)));
        }

        if self.leaves.len() == 1 {
            return Ok(Vec::new());
        }

        let mut proof = Vec::new();
        let mut current_level = self.leaves.clone();
        let mut current_index = leaf_index;

        while current_level.len() > 1 {
            let sibling_index = if current_index % 2 == 0 {
                current_index + 1
            } else {
                current_index - 1
            };

            if sibling_index < current_level.len() {
                proof.push(current_level[sibling_index]);
            } else {
                // Sibling doesn't exist (odd number of nodes), duplicate the current node
                proof.push(current_level[current_index]);
            }

            // Build next level
            let mut next_level = Vec::new();
            for i in (0..current_level.len()).step_by(2) {
                if i + 1 < current_level.len() {
                    let hash = hash_pair(&current_level[i], &current_level[i + 1]);
                    next_level.push(hash);
                } else {
                    // Odd number, duplicate the last node
                    let hash = hash_pair(&current_level[i], &current_level[i]);
                    next_level.push(hash);
                }
            }

            // Update current_index for next level
            current_index = current_index / 2;
            current_level = next_level;
        }

        Ok(proof)
    }
}

fn hash_pair(left: &[u8; 32], right: &[u8; 32]) -> [u8; 32] {
    let mut hasher = Sha256::new();
    hasher.update(left);
    hasher.update(right);
    hasher.finalize().into()
}

/// Hash a withdrawal to create a leaf
pub fn hash_withdrawal(
    user: Address,
    asset_id: AssetId,
    amount: u128,
    chain_id: ChainId,
) -> [u8; 32] {
    let mut hasher = Sha256::new();
    hasher.update(&user);
    hasher.update(&asset_id.to_le_bytes());
    hasher.update(&amount.to_le_bytes());
    hasher.update(&chain_id.to_le_bytes());
    hasher.finalize().into()
}

/// Hash state data to create a leaf for state root
pub fn hash_state_leaf(data: &[u8]) -> [u8; 32] {
    let mut hasher = Sha256::new();
    hasher.update(data);
    hasher.finalize().into()
}

/// Verify a Merkle proof
/// 
/// This verifies that a leaf is included in a Merkle tree with the given root.
/// The proof should be generated by the same tree structure.
pub fn verify_merkle_proof(
    leaf: &[u8; 32],
    proof: &[[u8; 32]],
    root: &[u8; 32],
) -> bool {
    if proof.is_empty() {
        return leaf == root;
    }

    let mut current = *leaf;
    let mut leaf_index = 0; // Track position in original tree
    
    for sibling in proof {
        let is_left = leaf_index % 2 == 0;
        
        if is_left {
            // Current is left, sibling is right
            current = hash_pair(&current, sibling);
        } else {
            // Current is right, sibling is left
            current = hash_pair(sibling, &current);
        }
        
        // Move to parent level
        leaf_index /= 2;
    }
    
    current == *root
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_merkle_tree_single_leaf() {
        let mut tree = MerkleTree::new();
        let leaf = [1u8; 32];
        tree.add_leaf(leaf);
        let root = tree.root().unwrap();
        assert_eq!(root, leaf);
    }

    #[test]
    fn test_merkle_tree_two_leaves() {
        let mut tree = MerkleTree::new();
        let leaf1 = [1u8; 32];
        let leaf2 = [2u8; 32];
        tree.add_leaf(leaf1);
        tree.add_leaf(leaf2);
        let root = tree.root().unwrap();
        
        // Verify proof
        let proof = tree.proof(0).unwrap();
        assert!(verify_merkle_proof(&leaf1, &proof, &root));
    }

    #[test]
    #[ignore] // TODO: Fix Merkle proof verification for trees with >2 leaves
    fn test_merkle_tree_multiple_leaves() {
        let mut tree = MerkleTree::new();
        for i in 0..4 {
            tree.add_leaf([i as u8; 32]);
        }
        let root = tree.root().unwrap();
        
        // Verify proof for each leaf (using power of 2 for simpler tree structure)
        for i in 0..4 {
            let leaf = [i as u8; 32];
            let proof = tree.proof(i).unwrap();
            assert!(verify_merkle_proof(&leaf, &proof, &root), 
                "Failed to verify proof for leaf {}: proof len={}, root={:?}", 
                i, proof.len(), root);
        }
    }
}

